<script>
```Parsing through stack/heap```
function red(x) {
    let y = x + 1;
    return y;
  }
  function blue(x) {
    let y = red(x);
    return y + 1;
  }
  function main(x) {
    let y = blue(x);
    return y;
  }
  let x = 1;
  console.log('results = ' + main(x));

```Types of objects```
  var intNum = 42;
  var floatNum = 3.14159;
  var nanNum = NaN;
  var infNum = Infinity;
  var ninfNum = -Infinity;
  var str = "hello world";
  var boolTrue = true;
  var boolFalse = false;
  var nullVal = null;
  var undefVal = undefined;
  var lst = ['a', 'b', 3, 4, 5, 'f']; ```not stored on the stack, only on the heap```
  var obj = {name: 'fred', age: 35, hasChildren: true}; ```not stored on the stack, only on the heap```
  var i = 5;
  var obj_list = [i, {foo; i+1, a: [1, 2, 3]}, {bar: i+2}];
  obj.name = 'Jane';
  obj["name"] = "Jake";


/* Block Scope

Types of variables

var
const
argument
let - limited by {} curly brackets/braces */

  function blue(x) {
  var y = 0;
  if (y <= 0){let x = y;
  x = x + 1;
  }
  y = y + 1;
  return y + 1;
}

var x = 1;
console.log('result = ' + blue(x));

/*Equals Operator
for objects on the heap but not referenced by anything from then stack, the heap will do garbage collection and remove the object from the stack.

Numbers are objects that DO have a place on the stack, so they are copied in instead of referenced in.*/

```x is the same object whether called with a or b```

let a = {x : 1}

const f1 = function f1(b){
  b.x = 3
  return b; ```this line is optional for getting x from b to a```
}
let result = f1(a)
console.log(result)

```Pass a function into another function:```
var red = function red(){
  return 3.141;
}
const blue = function blue(f){
  let y = f();
  return y;
}
var x = blue(red);

/*String and Numbers

This concatenates b onto a, so a = 3322*/

let a = '22' ```string```
let b = 33; ```number```
a = a + b;
b = b + true; ```b = 34, because true is parsed as 1```
b = b + Number(a); ```b is 55```
/*Adding a word string to a number will result in a NaN (not a number) error.*/


const locations = [ ];
const makePoint = function makePoint(x, y) {
    let p = { x: x, y: y};
    return p;
}
const factory = function factory(n){
  for(let i = 0;i < n; i++){
    let p = makePoint(i,i);
    locations.push(p);
  }
}
factory(3);

```Factory Functions```

console.log('locations: ' + JSON.stringify(locations));

const locations = [ ];
const makePoint = function makePoint(x, y) {
    let p = { x: x, y: y};
    return p;
}
const factory = function factory(n){
  for(let i = 0;i < n; i++){
    let p = makePoint(i,i);
    locations.push(p);
  }
}
factory(3);

console.log('locations: ' + JSON.stringify(locations));

```Hoisting functions and vars```

```function declaration```
function red(){return 1;} 

```function expression```
var blue = function(){return 2;}
var blue = function blue(){return 2;}
/* Even though the function hasn't been called yet, it's read by the interpreter. It's been hoisted.
If const is used instead, there will be a reference error. It will say blue is not defined.

ways to fix:
read function first, then execute.*/

/*We can use Chrome as a powerful web debugger. The dev tools have a callstack area in Sources with which one can step through the stack.*/ 
















</script>