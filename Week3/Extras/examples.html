<html>
Parsing through stack/heap<br>
<code>function red(x) {
    let y = x + 1;
    return y;
  }
  function blue(x) {
    let y = red(x);
    return y + 1;
  }
  function main(x) {
    let y = blue(x);
    return y;
  }
  let x = 1;
  console.log('results = ' + main(x));

```Types of objects```
  var intNum = 42;
  var floatNum = 3.14159;
  var nanNum = NaN;
  var infNum = Infinity;
  var ninfNum = -Infinity;
  var str = "hello world";
  var boolTrue = true;
  var boolFalse = false;
  var nullVal = null;
  var undefVal = undefined;
  var lst = ['a', 'b', 3, 4, 5, 'f']; ```not stored on the stack, only on the heap```
  var obj = {name: 'fred', age: 35, hasChildren: true}; ```not stored on the stack, only on the heap```
  var i = 5;
  var obj_list = [i, {foo; i+1, a: [1, 2, 3]}, {bar: i+2}];
  obj.name = 'Jane';
  obj["name"] = "Jake";

</code>

Block Scope<br>

Types of variables<br>
<ul>
    <li>var</li>
    <li>const</li>
    <li>argument</li>
    <li>let - limited by {} curly brackets/braces</li></ul>
<br>
<code>
  function blue(x) {
  var y = 0;
  if (y <= 0){let x = y;
  x = x + 1;
  }
  y = y + 1;
  return y + 1;
}

var x = 1;
console.log('result = ' + blue(x));
</code>
<br><br>
Equals Operator<br>
For objects on the heap but not referenced by anything from then stack, the heap will do garbage collection and remove the object from the stack.<br>

Numbers are objects that DO have a place on the stack, so they are copied in instead of referenced in.<br>
<code>
```x is the same object whether called with a or b```

let a = {x : 1}

const f1 = function f1(b){
  b.x = 3
  return b; ```this line is optional for getting x from b to a```
}
let result = f1(a)
console.log(result)

```Pass a function into another function:```
var red = function red(){
  return 3.141;
}
const blue = function blue(f){
  let y = f();
  return y;
}
var x = blue(red);
</code>
<br><br>
String and Numbers<br>

This concatenates b onto a, so a = 3322<br>
<code>
let a = '22' ```string```
let b = 33; ```number```
a = a + b;
b = b + true; ```b = 34, because true is parsed as 1```
b = b + Number(a); ```b is 55```
Adding a word string to a number will result in a NaN (not a number) error.


const locations = [ ];
const makePoint = function makePoint(x, y) {
    let p = { x: x, y: y};
    return p;
}
const factory = function factory(n){
  for(let i = 0;i < n; i++){
    let p = makePoint(i,i);
    locations.push(p);
  }
}
factory(3);

```Factory Functions```

console.log('locations: ' + JSON.stringify(locations));

const locations = [ ];
const makePoint = function makePoint(x, y) {
    let p = { x: x, y: y};
    return p;
}
const factory = function factory(n){
  for(let i = 0;i < n; i++){
    let p = makePoint(i,i);
    locations.push(p);
  }
}
factory(3);

console.log('locations: ' + JSON.stringify(locations));
</code>
<br><br>
<code>
```Hoisting functions and vars```

```function declaration```
function red(){return 1;} 

```function expression```
var blue = function(){return 2;}
var blue = function blue(){return 2;}</code><br><br>

Even though the function hasn't been called yet, it's read by the interpreter. It's been hoisted.<br>
If const is used instead, there will be a reference error. It will say blue is not defined.<br>

ways to fix:<br>
read function first, then execute.<br>

We can use Chrome as a powerful web debugger. The dev tools have a callstack area in Sources with which one can step through the stack.<br>

</html>
